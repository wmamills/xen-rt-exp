#!/bin/bash

#set -x

ME=$(readlink -f $0)
MY_NAME=$(basename $ME)
MY_DIR=$(dirname $ME)

NOW=$(date +%Y-%m-%d-%H%M%S)
LOG=test-log-$NOW.log

TMP_MARKER=test-qemu-marker

TOTAL=0
FAIL=0

RUNS=2
TRYS=2
BOOT_WAIT=30
SHUTDOWN_WAIT=30
TEST_WAIT=60
SSH_FAIL_COUNT=5
TRY_CONTINUE=true
#TESTS=( linux-domu )
TESTS=( dummy )

QEMU_SSH_NAME=qemu
QEMU_BOOT="./qemu-run.sh xen"
SESSION_NAME=test-qemu

error() {
    echo "$@"
    exit 2
}

tmux-panel-title() {
    printf '\033]2;%s\033\\' "$1"
}

update_totals() {
    echo "TOTAL=$TOTAL FAIL=$FAIL" >totals.txt
    echo "LAST $LAST_OK" >>totals.txt
    tac $LOG | grep FAIL | head -n 25 >>totals.txt
}

record_success() {
    TOTAL=$(( $TOTAL + 1 ))
    MSG="OK   $1 $2 $3"
    echo "$MSG"
    echo "$MSG" >>$LOG
    LAST_OK="$MSG"
    update_totals
}

record_failure() {
    TOTAL=$(( $TOTAL + 1 ))
    FAIL=$(( $FAIL + 1 ))
    MSG="FAIL $1 $2 $3"
    echo "$MSG"
    echo "$MSG" >>$LOG
    LAST_FAIL="$MSG"
    update_totals
}

wait_for_ssh() {
    echo -n "waiting for ssh "
    for i in $(seq 1 $BOOT_WAIT); do
        if ssh -o ConnectTimeout=2 $QEMU_SSH_NAME true >/dev/null 2>&1; then
            echo " OK"
            return
        fi
        echo -n "."
        sleep 1
    done
    echo
    echo "Failed to get ssh"
    false
}

###### Remote test support
remote_action() {
    scp $ME $QEMU_SSH_NAME:
    ssh $QEMU_SSH_NAME chmod +x ./$MY_NAME
    ssh $QEMU_SSH_NAME ./$MY_NAME subcmd "$@"
}

do_defer_start() {
    echo "start $@"
    rm -rf test-result.*
    echo "$ME subcmd $@" | at now + 0 minute  >test-result.start 2>&1
}

do_defer_test_run() {
    TEST=$1; shift
    set -o pipefail

    exec >/dev/console 2>&1 </dev/null
    if [ ! -r ${TEST}-test.sh ]; then
        error "${TEST}-test.sh does not exist!"
    else
        chmod +x ${TEST}-test.sh
    fi
    echo "sleeping 2 seconds to allow ssh to exit"
    sleep 2
    echo "starting test $TEST"
    ./${TEST}-test.sh run "$@" | tee test-result.log
    echo $? >test-result.done
}

check_ssh() {
    local time=$1
    local timeout=$2
    local fails=0

    echo -n "checking ssh (timeout $1 seconds) "
    for i in $(seq 1 $1); do
        if scp -o ConnectTimeout=2 \
            -o ServerAliveInterval=2 \
            -o ServerAliveCountMax=2 \
            $QEMU_SSH_NAME:test-result.* . >/dev/null 2>&1; then
            echo -n "."
            FAILS=0
            if [ -r test-result.done ]; then
                # allow the at job to finish and remove itself from the atq
                sleep 1

                if [ x"$(cat test-result.done)" = x"0" ]; then
                    CAUSE="OK"
                    echo " $CAUSE"
                    return 0
                else
                    CAUSE="FAIL"
                    echo " $CAUSE"
                    return 1
                fi
            fi
        else
            echo -n "!"
            FAILS=$(( $FAILS + 1 ))
            if [ $FAILS -gt $timeout ]; then
                CAUSE="HANG"
                echo " $CAUSE"
                return 1
            fi
        fi
        sleep 1
    done
    CAUSE="TIMEOUT"
    echo " $CAUSE"
    return 1
}

do_one_deferred_test() {
    echo "test $1"
    if [ ! -r $1-test.sh ]; then
        error "$1-test.sh does not exist!"
    fi
    rm -rf test-result.*
    scp $1-test.sh $QEMU_SSH_NAME:
    remote_action defer_start defer_test_run "$@"
    check_ssh $TEST_WAIT $SSH_FAIL_COUNT
}

do_one_quick_test() {
    echo "ssh command"
    ssh $QEMU_SSH_NAME true
}

do_one_test() {
    do_one_deferred_test $@
}

###### Shutdown support
qemu_running() {
    if [ -r qemu-run.pid ]; then
        ps --pid $(cat qemu-run.pid) >/dev/null
    else
        false
    fi
}

wait_qemu_stop() {
    echo -n "waiting for qemu to stop "
    for i in $(seq 1 $SHUTDOWN_WAIT); do
        if ! qemu_running; then
            echo " OK"
            return
        fi
        echo -n "."
        sleep 1
    done
    echo
    echo "qemu did not stop"
    false
}

do_defer_shutdown() {
    exec >/dev/console 2>&1 </dev/null
    echo "sleeping 2 seconds to allow ssh to exit"
    sleep 2
    echo "starting shutdown"
    shutdown now
}

do_shutdown() {
    remote_action defer_start defer_shutdown
    if ! wait_qemu_stop; then
        kill_qemu
    fi
}

kill_qemu() {
    if [ -r qemu-run.pid ]; then
        PID=$(cat qemu-run.pid)
    else
        return
    fi

    while qemu_running; do
            kill -3 $PID
            sleep 1
    done
}

###### Windows and main
do_totals() {
    tmux-panel-title "totals"
    watch -t -n 1 -d cat totals.txt
}

clean_tmp() {
    MY_TMPDIR=$(dirname $TMPDIR)
    if [ -e $MY_TMPDIR/test-qemu-tmp/$TMP_MARKER ]; then
        echo "cleaning our private tmp dir"
        rm -rf $MY_TMPDIR/test-qemu-tmp/* || true
        touch $MY_TMPDIR/test-qemu-tmp/$TMP_MARKER || error "Can't touch tmp marker"
    else
        echo "private tmp dir not found"
    fi
}

do_host() {
    tmux-panel-title "host side $@"
    sleep 2
    echo "RUNS=$RUNS TRYS=$TRYS TESTS=${TESTS[@]}"
    sleep 2

    #for i in $(seq 1 100); do echo "fake FAIL #$i" >>$LOG; done

    for run in $(seq 1 $RUNS); do
        for t in ${TESTS[@]}; do
            tmux-panel-title "run=$run test=$t boot"
            tmux split-window -h "$ME subcmd qemu $t"
            if wait_for_ssh 60; then 
                status=true
                try_shutdown=true
                for try in $(seq 1 $TRYS); do
                    tmux-panel-title "run=$run test=$t try=$try"
                    if ! do_one_test $t; then
                        record_failure $run $t $try
                        status=false
                        if [ x"$CAUSE" = x"HANG" ]; then
                            # if ssh is not working don't try shutdown
                            try_shutdown=false
                            break
                        elif [ x"$CAUSE" = x"TIMEOUT" ]; then
                            # for timeout we can't go on but we can try shutdown
                            break
                        elif ! $TRY_CONTINUE; then
                            # for fail we can go on if we want to
                            break
                        fi
                    else
                        record_success $run $t $try
                    fi
                done
                if $try_shutdown; then
                    do_shutdown
                else
                    kill_qemu
                fi
            else
                record_failure $run $t 0
                kill_qemu
            fi
            echo "sleeping before cleaning"
            sleep 1
            clean_tmp
            echo "sleeping before next run"
            sleep 1
        done
    done
    tmux kill-win
}

do_qemu() {
    tmux-panel-title "$QEMU_BOOT $@"
    QEMU_TMUX=no $QEMU_BOOT "$@"
}

main() {
    echo "Starting..." >totals.txt

    if [ -n "$TMUX" ]; then
        echo "nested tmux not supported"
        exit 2
    fi

    : ${TMPDIR:=/tmp}
    export MY_TMPDIR=$(mktemp -d -p $TMPDIR test-qemu-XXXXXXXX)
    mkdir -p $MY_TMPDIR/test-qemu-tmp || error "Can't create tmp dir"
    if ! touch $MY_TMPDIR/test-qemu-tmp/$TMP_MARKER; then
        error "Can't create private tmpdir"
    fi
    export TMPDIR=$MY_TMPDIR/test-qemu-tmp

    tmux start-server
    tmux new-session -d -s QEMU -n $QEMU_WIN_NAME -d "$ME subcmd totals"
    SESS="QEMU"
    tmux set -s -t $SESS mouse on

    tmux set -w -t $SESS:$QEMU_WIN_NAME pane-border-status top

    # the host pane is the driver of it all
    # create it and let it create and destroy the qemu pane
    tmux split-window -v -l $(( $LINES - 10 )) -t $SESS:$QEMU_WIN_NAME "$ME subcmd host"

    #sleep 1
    #tmux select-pane -t $SESS:$QEMU_WIN_NAME.1

    tmux attach -t$SESS:$QEMU_WIN_NAME

    # if finsihed or killed (but not detached)
    if ! tmux has -t$SESS; then
        clean_tmp
    fi
}

if [ -e ./test-qemu-vars ]; then
    . ./test-qemu-vars
fi

if [ x"$1" = x"subcmd" ]; then
    CMD=$2
    shift; shift;
    do_$CMD "$@"
else
    main "$@"
fi