#!/bin/bash

# Boot a qemu machine and runs tests on it
# use tmux to visualize status while running
# record the results in test logs
# handle test OK, FAIL, TIMEOUT, and HANG
# handle boot failures (of target software or qemu itself)
#
# For RUNS
#    For each TESTS
#       Boot QEMU and wait for ready
#       For TRYS
#           run test on target while watching status from host
#           record status
#           if ! recoverable failure
#                break
#        if ! hung
#           attempt to shutdown qemu gracefully
#        else
#           kill qemu
#

#set -x

ME=$(readlink -f $0)
MY_NAME=$(basename $ME)
MY_DIR=$(dirname $ME)

NOW=$(date +%Y-%m-%d-%H%M%S)
LOG=test-log-$NOW.log

TMP_MARKER=test-qemu-marker

RUNS=2
TRYS=2
BOOT_WAIT=30
SHUTDOWN_WAIT=30
TEST_WAIT=60
SSH_FAIL_COUNT=5
TRY_CONTINUE=true
TESTS=( dummy )

FILTER_TOTALS=true

QEMU_SSH_NAME=qemu
QEMU_BOOT="./qemu-run xen"
SESSION_NAME=test-qemu

error() {
    echo "$@"
    exit 2
}

tmux-panel-title() {
    printf '\033]2;%s\033\\' "$1"
}

format_msg() {
    MSG1=$(printf "%-8s %4d %-8s %s" $1 $2 $3 $4)
    shift 4
    echo "$MSG1 $@"
}

update_totals() {
    echo "TOTAL=$TOTAL FAIL=$FAIL" >totals.new
    echo "LAST $LAST_OK" >>totals.new
    if $FILTER_TOTALS; then
        tac $LOG | grep -v "OK " | head -n 25 >>totals.new
    else
        echo "LAST $LAST_FAIL" >>totals.new
        tac $LOG | head -n 25 >>totals.new
    fi
    mv -f totals.new totals.txt
}

init_totals() {
    LAST_OK=$(printf "%-8s %s" OK none)
    LAST_FAIL=$(printf "%-8s %s" FAIL none)
    TOTAL=0
    FAIL=0
    update_totals
}


record_success() {
    TOTAL=$(( $TOTAL + 1 ))
    MSG=$(format_msg "$@")
    echo "$MSG"
    echo "$MSG" >>$LOG
    LAST_OK="$MSG"
    update_totals
}

record_failure() {
    TOTAL=$(( $TOTAL + 1 ))
    FAIL=$(( $FAIL + 1 ))
    MSG=$(format_msg "$@")
    echo "$MSG"
    echo "$MSG" >>$LOG
    LAST_FAIL="$MSG"
    update_totals
}

wait_for_ssh() {
    echo -n "waiting for ssh "
    for i in $(seq 1 $BOOT_WAIT); do
        if ssh -o ConnectTimeout=2 $QEMU_SSH_NAME true >/dev/null 2>&1; then
            echo " OK"
            return
        fi
        echo -n "."
        sleep 1
    done
    echo
    echo "Failed to get ssh"
    false
}

###### Remote test support

# we are on the host, perform a subcmd on the target
remote_action() {
    scp $ME $QEMU_SSH_NAME:
    ssh $QEMU_SSH_NAME chmod +x ./$MY_NAME
    ssh $QEMU_SSH_NAME ./$MY_NAME subcmd "$@"
}

# we are on the target, start an detached action
# (The actual deferral delay is in the action function)
do_defer_start() {
    echo "start $@"
    rm -rf test-result.*
    echo "$ME subcmd $@" | at now + 0 minute  >test-result.start 2>&1
}

# we are on the target, this is the action for a deferred test run
do_defer_test_run() {
    TEST=$1; shift
    set -o pipefail

    exec >/dev/console 2>&1 </dev/null
    if [ ! -r ${TEST}-test.sh ]; then
        error "${TEST}-test.sh does not exist!"
    else
        chmod +x ${TEST}-test.sh
    fi
    echo "sleeping 2 seconds to allow ssh to exit"
    sleep 2
    echo "starting test $TEST"
    ./${TEST}-test.sh run "$@" | tee test-result.log
    echo $? >test-result.done
}

# we are on the host
# use ssh to check on the target and see if the deferred test is done
#
# returns 0 for test completed with 0 exit status
# returns !0 for anything else
# always sets global var CAUSE
check_ssh() {
    local time=$1
    local timeout=$2
    local fails=0

    echo -n "checking ssh (timeout $1 seconds) "
    for i in $(seq 1 $1); do
        if scp -o ConnectTimeout=2 \
            -o ServerAliveInterval=2 \
            -o ServerAliveCountMax=2 \
            $QEMU_SSH_NAME:test-result.* . >/dev/null 2>&1; then
            echo -n "."
            FAILS=0
            if [ -r test-result.done ]; then
                # allow the at job to finish and remove itself from the atq
                sleep 1

                if [ x"$(cat test-result.done)" = x"0" ]; then
                    CAUSE="OK"
                    echo " $CAUSE"
                    return 0
                else
                    CAUSE="FAIL"
                    echo " $CAUSE"
                    return 1
                fi
            fi
        else
            echo -n "!"
            FAILS=$(( $FAILS + 1 ))
            if [ $FAILS -gt $timeout ]; then
                CAUSE="HANG"
                echo " $CAUSE"
                return 1
            fi
        fi
        sleep 1
    done
    CAUSE="TIMEOUT"
    echo " $CAUSE"
    return 1
}

# perform a test on the target in a deferred way
# the test itself will be a separate file
#
# we use deferred tests for anything that may cause the target
# (or the emulator) to hang
#
# returns 0 for test completed with 0 exit status
# returns !0 for anything else
# always sets global var CAUSE
do_one_deferred_test() {
    echo "test $1"
    if [ ! -r $1-test.sh ]; then
        error "$1-test.sh does not exist!"
    fi
    rm -rf test-result.*
    scp $1-test.sh $QEMU_SSH_NAME:
    remote_action defer_start defer_test_run "$@"
    check_ssh $TEST_WAIT $SSH_FAIL_COUNT
}

do_one_quick_test() {
    echo "ssh command"
    ssh $QEMU_SSH_NAME true
}

do_one_test() {
    do_one_deferred_test $@
}

###### Shutdown support
qemu_running() {
    if [ -r qemu-run.pid ]; then
        ps --pid $(cat qemu-run.pid) >/dev/null
    else
        false
    fi
}

wait_qemu_stop() {
    echo -n "waiting for qemu to stop "
    for i in $(seq 1 $SHUTDOWN_WAIT); do
        if ! qemu_running; then
            echo " OK"
            return
        fi
        echo -n "."
        sleep 1
    done
    echo
    echo "qemu did not stop"
    false
}

do_defer_shutdown() {
    exec >/dev/console 2>&1 </dev/null
    echo "sleeping 2 seconds to allow ssh to exit"
    sleep 2
    echo "starting shutdown"
    shutdown now
}

do_shutdown() {
    remote_action defer_start defer_shutdown
    if ! wait_qemu_stop; then
        kill_qemu
    fi
}

kill_qemu() {
    if [ -r qemu-run.pid ]; then
        PID=$(cat qemu-run.pid)
    else
        return
    fi

    while qemu_running; do
            kill -3 $PID
            sleep 1
    done
}

###### Windows and main
do_totals() {
    tmux-panel-title "totals"
    watch -t -n 1 -d cat totals.txt
}

clean_tmp() {
    MY_TMPDIR=$(dirname $TMPDIR)
    if [ -e $MY_TMPDIR/test-qemu-tmp/$TMP_MARKER ]; then
        echo "cleaning our private tmp dir"
        rm -rf $MY_TMPDIR/test-qemu-tmp/* || true
        touch $MY_TMPDIR/test-qemu-tmp/$TMP_MARKER || error "Can't touch tmp marker"
    else
        echo "private tmp dir not found"
    fi
}

do_host() {
    tmux-panel-title "host side $@"
    init_totals
    echo "RUNS=$RUNS TRYS=$TRYS TESTS=${TESTS[@]}"

    for run in $(seq 1 $RUNS); do
        for t in ${TESTS[@]}; do
            tmux-panel-title "run=$run test=$t boot"
            tmux split-window -h "$ME subcmd qemu $t"
            if wait_for_ssh $BOOT_WAIT; then
                status=true
                try_shutdown=true
                for try in $(seq 1 $TRYS); do
                    tmux-panel-title "run=$run test=$t try=$try"
                    if ! do_one_test $t; then
                        record_failure $CAUSE $run $t $try
                        status=false
                        if [ x"$CAUSE" = x"HANG" ]; then
                            # if ssh is not working don't try shutdown
                            try_shutdown=false
                            break
                        elif [ x"$CAUSE" = x"TIMEOUT" ]; then
                            # for timeout we can't go on but we can try shutdown
                            break
                        elif ! $TRY_CONTINUE; then
                            # for fail we can go on if we want to
                            break
                        fi
                    else
                        record_success OK $run $t $try
                    fi
                done
                if $try_shutdown; then
                    do_shutdown
                else
                    kill_qemu
                fi
            else
                record_failure NOBOOT $run $t 0
                kill_qemu
            fi
            echo "sleeping before cleaning"
            sleep 1
            clean_tmp
            echo "sleeping before next run"
            sleep 1
        done
    done
    tmux kill-win
}

# This is the tmux window pane function to actually run qemu
do_qemu() {
    tmux-panel-title "$QEMU_BOOT $@"
    QEMU_TMUX=no $QEMU_BOOT "$@"
}

# main starts things up and then waits for tmux to finish or detach
main() {
    if [ -n "$TMUX" ]; then
        echo "nested tmux not supported"
        exit 2
    fi

    : ${TMPDIR:=/tmp}
    export MY_TMPDIR=$(mktemp -d -p $TMPDIR test-qemu-XXXXXXXX)
    mkdir -p $MY_TMPDIR/test-qemu-tmp || error "Can't create tmp dir"
    if ! touch $MY_TMPDIR/test-qemu-tmp/$TMP_MARKER; then
        error "Can't create private tmpdir"
    fi
    export TMPDIR=$MY_TMPDIR/test-qemu-tmp

    touch $LOG
    echo "Starting..." >totals.txt

    tmux start-server
    tmux new-session -d -s QEMU -n $QEMU_WIN_NAME -d "$ME subcmd totals"
    SESS="QEMU"
    tmux set -s -t $SESS mouse on

    tmux set -w -t $SESS:$QEMU_WIN_NAME pane-border-status top

    # the host pane is the driver of it all
    # create it and let it create and destroy the qemu pane
    tmux split-window -v -l $(( $LINES - 10 )) -t $SESS:$QEMU_WIN_NAME "$ME subcmd host"

    #sleep 1
    #tmux select-pane -t $SESS:$QEMU_WIN_NAME.1

    tmux attach -t$SESS:$QEMU_WIN_NAME

    # if finished or killed (but not detached)
    if ! tmux has -t$SESS >/dev/null 2>&1; then
        clean_tmp
        cat totals.txt
    fi
}

if [ -e ./test-qemu-vars ]; then
    . ./test-qemu-vars
fi

if [ x"$1" = x"subcmd" ]; then
    CMD=$2
    shift; shift;
    do_$CMD "$@"
elif [ x"$1" = x"help" ]; then
    echo "this runs a sequence of tests using qemu"
    echo "look at test-qemu-vars for examples"
    exit 2
else
    main "$@"
fi